"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6194],{9613:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>f});var a=t(9496);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),d=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=d(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(t),m=o,f=p["".concat(s,".").concat(m)]||p[m]||u[m]||i;return t?a.createElement(f,r(r({ref:n},c),{},{components:t})):a.createElement(f,r({ref:n},c))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:o,r[1]=l;for(var d=2;d<i;d++)r[d]=t[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9890:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=t(7366),o=(t(9496),t(9613));const i={sidebar_position:36,description:"Loading relations on a model's instances."},r="Loading models relations",l={unversionedId:"guides/models/models-relations-loading",id:"guides/models/models-relations-loading",title:"Loading models relations",description:"Loading relations on a model's instances.",source:"@site/docs/guides/models/models-relations-loading.md",sourceDirName:"guides/models",slug:"/guides/models/models-relations-loading",permalink:"/foscia/docs/guides/models/models-relations-loading",draft:!1,editUrl:"https://github.com/paul-thebaud/foscia/tree/main/website/docs/guides/models/models-relations-loading.md",tags:[],version:"current",lastUpdatedAt:1688508156,formattedLastUpdatedAt:"Jul 4, 2023",sidebarPosition:36,frontMatter:{sidebar_position:36,description:"Loading relations on a model's instances."},sidebar:"docsSidebar",previous:{title:"Tracking models changes",permalink:"/foscia/docs/guides/models/models-changes-tracking"},next:{title:"Actions",permalink:"/foscia/docs/category/actions"}},s={},d=[{value:"Checking loading state",id:"checking-loading-state",level:2},{value:"Loading relations",id:"loading-relations",level:2},{value:"Loading relation using refresh",id:"loading-relation-using-refresh",level:3},{value:"Options",id:"options",level:4},{value:"<code>chunk: (instances: ModelInstance[]): ModelInstance[][]</code>",id:"chunk-instances-modelinstance-modelinstance",level:5},{value:"<code>prepare: (action: Action, context: { instances: ModelInstance[]; relations: string[] }): Awaitable&lt;void&gt;</code>",id:"prepare-action-action-context--instances-modelinstance-relations-string--awaitablevoid",level:5},{value:"Loading relation using path",id:"loading-relation-using-path",level:3}],c={toc:d},p="wrapper";function u(e){let{components:n,...t}=e;return(0,o.kt)(p,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"loading-models-relations"},"Loading models relations"),(0,o.kt)("admonition",{title:"What you'll learn",type:"tip"},(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"Checking if relations are loaded"),(0,o.kt)("li",{parentName:"ul"},"Creating functions which will load your relations"),(0,o.kt)("li",{parentName:"ul"},"Configuring those functions to match your needs"))),(0,o.kt)("h2",{id:"checking-loading-state"},"Checking loading state"),(0,o.kt)("p",null,"If you want to check if an instance's relations (or deep relations) are loaded,\nyou can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"loaded")," function."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"loaded")," recursively inspect relations. This means it will only return ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," if\n",(0,o.kt)("strong",{parentName:"p"},"all")," relations of the instance (and sub-instances for deep relations) are\nloaded."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { loaded } from 'foscia/core';\n\n// True if comments is loaded.\nloaded(myPost, 'comments');\n// True if comments and each author of comments are loaded.\nloaded(myPost, 'comments.author');\n")),(0,o.kt)("h2",{id:"loading-relations"},"Loading relations"),(0,o.kt)("p",null,"Since Foscia uses a functional approach for your action, you are able to load a\nrelation using different ways depending on your data source implementation."),(0,o.kt)("p",null,"For this, Foscia provides multiple loader factories providing various options."),(0,o.kt)("h3",{id:"loading-relation-using-refresh"},"Loading relation using refresh"),(0,o.kt)("p",null,"This is the simplest way of loading relations if your data source implementation\nprovides an inclusion of relations and a way to filter models based on IDs (e.g.\nJSON:API)."),(0,o.kt)("p",null,"This loader will target the model index and include the requested relations. It\nsupports nested relations keys if your data source supports them."),(0,o.kt)("p",null,"Here is an example when using a JSON:API backend with an ",(0,o.kt)("inlineCode",{parentName:"p"},"ids")," filter available."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="loaders/refreshLoad.ts"',title:'"loaders/refreshLoad.ts"'},"import { makeRefreshIncludeLoader } from 'foscia/core';\nimport { filterBy } from 'foscia/jsonapi';\n\nexport default makeRefreshIncludeLoader({\n    prepare: (action, { instances }) =>\n        action.use(filterBy({ ids: instances.map((i) => i.id) })),\n});\n")),(0,o.kt)("p",null,"You can now use the loader on any instance."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import refreshLoad from './loaders/refreshLoad';\n\nawait refreshLoad(myPost, 'comments');\nawait refreshLoad(myPostArray, ['comments', 'comments.author']);\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"This loader is recommended as it will only run one action for many models and\nrelations. But, be aware that you should implement an adapted ",(0,o.kt)("inlineCode",{parentName:"p"},"prepare")," to\nfilter the fetched models (this will avoid overloading your data source with\nuseless records fetching).")),(0,o.kt)("h4",{id:"options"},"Options"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"makeRefreshIncludeLoader")," provides multiple options:"),(0,o.kt)("h5",{id:"chunk-instances-modelinstance-modelinstance"},(0,o.kt)("inlineCode",{parentName:"h5"},"chunk: (instances: ModelInstance[]): ModelInstance[][]")),(0,o.kt)("p",null,"A function to split the instances array to multiple arrays (e.g. to avoid\nhitting pagination limit)."),(0,o.kt)("h5",{id:"prepare-action-action-context--instances-modelinstance-relations-string--awaitablevoid"},(0,o.kt)("inlineCode",{parentName:"h5"},"prepare: (action: Action, context: { instances: ModelInstance[]; relations: string[] }): Awaitable<void>")),(0,o.kt)("p",null,"A function to execute before running action allowing you to prepare the refresh\naction (e.g. to avoid fetching a full list of models by filtering on instances'\nIDs)."),(0,o.kt)("h3",{id:"loading-relation-using-path"},"Loading relation using path"),(0,o.kt)("p",null,"This method is best suited for one instance relation loading with\nimplementations providing relation reading through a dedicated endpoint/query,\nsuch as JSON:API."),(0,o.kt)("p",null,"It does not support nested relations keys as it will be dangerously inefficient."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="loaders/forRelationLoad.ts"',title:'"loaders/forRelationLoad.ts"'},"import { makeRefreshIncludeLoader } from 'foscia/core';\n\nexport default makeForRelationLoader();\n")),(0,o.kt)("p",null,"You can now use the loader on any instance."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import forRelationLoad from './loaders/forRelationLoad';\n\nawait forRelationLoad(myPost, 'comments');\n")),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Because this loader will run one action per instance and relation, it is only\nrecommended for one instance's relation loading, not many.")))}u.isMDXComponent=!0}}]);