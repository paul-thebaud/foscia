"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[671],{9613:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||a;return n?o.createElement(f,i(i({ref:t},u),{},{components:n})):o.createElement(f,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},75:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(4250),r=(n(9496),n(9613));const a={sidebar_position:1},i="Introduction",s={unversionedId:"intro",id:"intro",title:"Introduction",description:"What is Func Model?",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/func-model/docs/intro",draft:!1,editUrl:"https://github.com/paul-thebaud/func-model/tree/main/website/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Installation",permalink:"/func-model/docs/installation"}},l={},c=[{value:"What is Func Model?",id:"what-is-func-model",level:2},{value:"How those it work?",id:"how-those-it-work",level:2},{value:"Short explanation",id:"short-explanation",level:3},{value:"Benefits of functional programming",id:"benefits-of-functional-programming",level:3},{value:"For Typescript, strong types works!",id:"for-typescript-strong-types-works",level:3}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"introduction"},"Introduction"),(0,r.kt)("h2",{id:"what-is-func-model"},"What is Func Model?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Func Model")," is a simple functional programming oriented API client. It is\nframework-agnostic and can integrate with any Web app using Javascript or\nTypescript."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Modular, highly extensible and fully treeshakable"),(0,r.kt)("li",{parentName:"ul"},"Ready to use functions to integrate with any ",(0,r.kt)("a",{parentName:"li",href:"https://jsonapi.org/"},"JSON:API")),(0,r.kt)("li",{parentName:"ul"},"Strongly typed everywhere, with generics typings on models, actions, etc."),(0,r.kt)("li",{parentName:"ul"},"Dependency free (JSON:API adapter is based\non ",(0,r.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"},"fetch API"),")"),(0,r.kt)("li",{parentName:"ul"},"(coming soon) Fully linted, tested and documented")),(0,r.kt)("h2",{id:"how-those-it-work"},"How those it work?"),(0,r.kt)("h3",{id:"short-explanation"},"Short explanation"),(0,r.kt)("p",null,"Purpose of Func Model is to let you declare models object containing attributes\nand relationships (called a schema). Those model can also contain custom\ngetters, setters, methods or properties."),(0,r.kt)("p",null,"Once your model are defined, you can use them through your declared action\nfactory. The action factory is a configured base context for all your API\ninteractions which you need to declare (this avoids useless functions or class\nbeing in your production bundle if you do not use them)."),(0,r.kt)("p",null,"With this action factory, you can run API action (GET, POST, etc.) using context\nchangers and runners."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// post.js - We declare a post model with the provided schema and extensions.\nexport default makeModel('posts', {\n  // The schema to interact with our API.\n  title: attr({ default: '' }),\n  description: attr(),\n  comments: hasMany(),\n  createdAt: attr(dateTransformer()),\n  publishedAt: attr(dateTransformer()),\n}, {\n  // Our extensions function for the model.\n  get isPublished() {\n    return !!this.publishedAt;\n  },\n});\n\n// main.js - We use this post schema through our configured action factory.\nimport action from './your/project/action';\nimport Post from './your/project/post';\n\nconst posts = await action()\n  .use(forModel(Post))\n  .use(include('comments'))\n  .run(all());\n\nposts[0].title; // \"Hello World\"\nposts[0].comments; // `Comment` model instances as an array.\n\nawait action().run(update(\n  fill(posts[0], { title: 'Hello from Func Model' }),\n));\n\nposts[0].title; // \"Hello from Func Model\"\n")),(0,r.kt)("h3",{id:"benefits-of-functional-programming"},"Benefits of functional programming"),(0,r.kt)("p",null,"The way you will declare your models and run your action is called functional\nprogramming. The base model and action objects are very small, and you are\ninteracting with those using functions. This way, if you do not use a feature of\nFunc Model (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"HasMany")," relations or ",(0,r.kt)("inlineCode",{parentName:"p"},"fields")," JSON:API param), it won't be\nincluded in your final production bundle thanks to treeshaking."),(0,r.kt)("h3",{id:"for-typescript-strong-types-works"},"For Typescript, strong types works!"),(0,r.kt)("p",null,"Keeping types when using functional programming might be a little tricky when\nusing Typescript. Func Model is designed with generic types where it is useful,\nallowing your model interaction or action context changes to be strictly typed."),(0,r.kt)("p",null,"If we take the previous example and transform it to Typescript, we have a lot of\nbenefits:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// post.js - We declare the Post model using class to be able to only import\n// types when relating the Post model in other models,\n// such as the following Comment import.\nimport type Comment from './your/project/comment';\n\nexport default class Post extends makeModel('posts', {\n  // Title attribute is infered as string from default value.\n  title: attr({ default: '' }),\n  // We can also pass a custom type.\n  description: attr<string>(),\n  comments: hasMany<Comment>(),\n  // Infered as `Date` from transformer.\n  createdAt: attr(dateTransformer()),\n  // We may also override the infered type from transformer.\n  publishedAt: attr<Date | null>(dateTransformer()),\n}, {\n  get isPublished() {\n    // `this` context is available with the correct typing in extensions.\n    // Here, `this.publishedAt` is a nullable Date.\n    return !!this.publishedAt;\n  },\n}) {\n  shortenDescription() {\n    // We can also use a strongly typed `this` inside the class body.\n    return this.description.substring(0, 50);\n  }\n}\n\n// main.js\nimport action from './your/project/action';\nimport Post from './your/project/post';\n\nconst posts = await action()\n  // We are telling the action context is now for the Post model.\n  .use(forModel(Post))\n  // We can now use this action context to strongly type context changers params.\n  // As an example, `include` is typed for deep dotted relations, such as:\n  // \"comments\", \"comments.author\", \"comments.author.favoritePosts\", etc.\n  .use(include('comments'))\n  .run(all());\n\nposts[0].title; // Type: `string`\nposts[0].comments; // Type: `Comment[]`\n\n// Strong types are available everywhere, even in small helpers such as `fill`.\nawait action().run(update(\n  fill(posts[0], { title: 'Hello from Func Model' }),\n));\n\nposts[0].title; // \"Hello from Func Model\"\n")))}p.isMDXComponent=!0}}]);